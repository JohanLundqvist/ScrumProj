
@{
    ViewBag.Title = "EditEntryView";
}

@model ScrumProj.Models.EntryViewModel
@{
    ViewBag.Title = "Blogpage";
}
<div class="row">
    @using (Html.BeginForm("EditEntry", "Entry", FormMethod.Post, new { enctype = "multipart/form-data" }))
    {

        <div class="col-md-6">
            <h2>Redigera Inlägg</h2>
            <div class="form-group">
                <label class="col-form-label" for="inputDefault">Titel</label>
                @Html.TextBoxFor(u => u.entry.Title, new { @class = "form-control", id = "inputDefault" })
            </div>
            <div class="form-control-static panel-primary" style="width: 100%">
                <div class="form-group" style="width:100%">
                    <div>
                        @Html.TextAreaFor(u => u.entry.Content, new { @class = "form-control", rows = "3", style = "min-width: 100%" })
                    </div>
                </div>
                <div class="form-group">
                    <label>Lägg till kategori:</label>
                    <input class="form-control" id="tags" name="tags" />
                </div>
                <label for="exampleInputFile">Bifoga</label>
                <div class="form-group">
                    <div>
                        <input type="file" id="newFile" name="newFile" />
                        <small id="fileHelp" class="form-text text-muted">This is some placeholder block-level help text for the above input. It's a bit lighter and easily wraps to a new line.</small>
                    </div>
                </div>
                <div class="form-group">
                    <div>
                        <input type="submit" value="Submit" class="btn btn-info" style="float:right" />
                        @Html.TextBoxFor(model => model.entry.fileId, new { @class = "invisible" })
                        @Html.TextBoxFor(model => model.entry.Id, new { @class = "invisible" })
                    </div>
                </div>
            </div>
        </div>
    }
    @Html.Action("_DeleteCategoryPartial", new { model = Model})
</div>

        @section scripts {

            <script src="~/Scripts/jquery-3.3.1.js"></script>
            <link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
            <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

            <script>

    var myFile = document.getElementById('newFile');


    myFile.addEventListener('change', function () {
        if (this.files[0].size > 4000000) {
            alert("Filen är för stor, gränsen är 4 mb");
            myFile.value = "";
        }

    });

        var availableTags = [];

        @foreach (var c in Model.Categories)
        {
            @:availableTags.push("@c.Name");
        }
        var faux = $("#faux");
        var arrayused;
        var calcfaux;
        var retresult;
        var checkspace;
        var contents = $('#tags')[0];
        var carpos;
        var fauxpos;
        var tier;
        var startss;
        var endss;
        function getCaret(el) {
            if (el.selectionStart) {
                return el.selectionStart;
            } else if (document.selection) {
                el.focus();

                var r = document.selection.createRange();
                if (r == null) {
                    return 0;
                }

                var re = el.createTextRange(),
                    rc = re.duplicate();
                re.moveToBookmark(r.getBookmark());
                rc.setEndPoint('EndToStart', re);

                return rc.text.length;
            }
            return 0;
        }

        function split(val) {
            return val.split(/ \s*/);
        }
        function extractLast(term) {
            return split(term).pop();
        }
        $("#tags")
            .on("keydown", function (event) {
                if (event.keyCode === $.ui.keyCode.TAB &&
                    $(this).data("autocomplete").menu.active) {
                    event.preventDefault();
                }
            })
            .click(function (event) {
                carpos = getCaret(contents);
                fauxpos = faux.text().length;
                if (carpos < fauxpos) {
                    tier = "close";
                    $(this).autocomplete("close");
                    startss = this.selectionStart;
                    endss = this.selectionEnd;
                    $(this).val($(this).val().replace(/ *$/, ''));
                    this.setSelectionRange(startss, endss);
                }
                else {
                    tier = "open";
                }

            })
            .on("keyup", function (event) {
                calcfaux = faux.text($(this).val());
                fauxpos = faux.text().length;
                if (/ $/.test(faux.text()) || tier === "close") {
                    checkspace = "space";
                }
                else {
                    checkspace = "nospace";
                }


                if (fauxpos <= 1) {
                    tier = "open";
                }
                carpos = getCaret(contents);
                if (carpos < fauxpos) {
                    tier = "close";
                    $(this).autocomplete("close");
                    startss = this.selectionStart;
                    endss = this.selectionEnd;
                    $(this).val($(this).val().replace(/ *$/, ''));
                    this.setSelectionRange(startss, endss);
                }
                else {
                    tier = "open";
                }
            })
            //mouse caret position dropdown
            .autocomplete({
                minLength: 1,
                search: function (event, ui) {
                    var input = $(event.target);
                    // custom minLength
                    if (checkspace === "space") {
                        input.autocomplete("close");
                        return false;
                    }
                },
                source: function (request, response) {

                    var term = $.ui.autocomplete.escapeRegex(extractLast(request.term))
                        // Create two regular expressions, one to find suggestions starting with the user's input:
                        , startsWithMatcher = new RegExp("^" + term, "i")
                        , startsWith = $.grep(availableTags, function (value) {
                            return startsWithMatcher.test(value.label || value.value || value);
                        })
                        // ... And another to find suggestions that just contain the user's input:
                        , containsMatcher = new RegExp(term, "i")
                        , contains = $.grep(availableTags, function (value) {
                            return $.inArray(value, startsWith) < 0 &&
                                containsMatcher.test(value.label || value.value || value);
                        });

                    // Supply the widget with an array containing the suggestions that start with the user's input,
                    // followed by those that just contain the user's input.
                    response(startsWith.concat(contains));
                },
                open: function (event, ui) {
                    var input = $(event.target),
                        widget = input.autocomplete("widget"),
                        style = $.extend(input.css([
                            "font",
                            "border-left",
                            "padding-left"
                        ]), {
                                position: "absolute",
                                visibility: "hidden",
                                "padding-right": 0,
                                "border-right": 0,
                                "white-space": "pre"
                            }),
                        div = $("<div/>"),
                        pos = {
                            my: "left top",
                            collision: "none"
                        },
                        offset = -7; // magic number to align the first letter
                    // in the text field with the first letter
                    // of suggestions
                    // depends on how you style the autocomplete box

                    widget.css("width", "");

                    div
                        .text(input.val().replace(/\S*$/, ""))
                        .css(style)
                        .insertAfter(input);
                    offset = Math.min(
                        Math.max(offset + div.width(), 0),
                        input.width() - widget.width()
                    );
                    div.remove();

                    pos.at = "left+" + offset + " bottom";
                    input.autocomplete("option", "position", pos);

                    widget.position($.extend({ of: input }, pos));
                },
                focus: function () {
                    // prevent value inserted on focus
                    return false;
                },
                select: function (event, ui) {
                    var terms = split(this.value);
                    startss = this.selectionStart;
                    endss = this.selectionEnd;
                    // remove the current input
                    terms.pop();
                    // add the selected item
                    terms.push(ui.item.value);
                    // add placeholder to get the comma-and-space at the end
                    terms.push("");
                    this.setSelectionRange(startss, endss);
                    this.value = terms.join(" ");
                    calcfaux = faux.text($(this).val());
                    if (/ $/.test(faux.text())) {
                        checkspace = "space";
                    }
                    else {
                        checkspace = "nospace";
                    }
                    carpos = getCaret(contents);
                    fauxpos = faux.text().length;
                    return false;
                }
            });
            </script>
        }
